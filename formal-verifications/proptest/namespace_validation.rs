//! Property-based tests for namespace name validation.
//!
//! Tests the namespace validation function (src/namespace/manager.rs:229-240)
//! with boundary cases: unicode, special characters, empty strings, max length.
//!
//! To run: add `proptest = "1"` to [dev-dependencies] in Cargo.toml, then
//!   cp formal-verifications/proptest/namespace_validation.rs tests/proptest_namespace.rs
//!   cargo test --test proptest_namespace

use proptest::prelude::*;

// ---- Production Implementation (mirrors src/namespace/manager.rs:229-240) ----

/// Validate a namespace name: 1-255 chars, starts with alphanumeric,
/// only contains `[a-zA-Z0-9._-]`.
fn is_valid_namespace_name(name: &str) -> bool {
    if name.is_empty() || name.len() > 255 {
        return false;
    }
    let bytes = name.as_bytes();
    if !bytes[0].is_ascii_alphanumeric() {
        return false;
    }
    bytes
        .iter()
        .all(|&b| b.is_ascii_alphanumeric() || b == b'-' || b == b'_' || b == b'.')
}

// ---- Reference Implementation (regex-based, obviously correct) ----

fn reference_validate(name: &str) -> bool {
    if name.is_empty() || name.len() > 255 {
        return false;
    }
    // First char must be alphanumeric
    let first = name.chars().next().unwrap();
    if !first.is_ascii_alphanumeric() {
        return false;
    }
    // All chars must be [a-zA-Z0-9._-]
    name.chars()
        .all(|c| c.is_ascii_alphanumeric() || c == '.' || c == '_' || c == '-')
}

// ---- Proptest Strategies ----

/// Generate valid namespace names.
fn arb_valid_name() -> impl Strategy<Value = String> {
    prop::string::string_regex("[a-zA-Z0-9][a-zA-Z0-9._-]{0,49}")
        .unwrap()
        .prop_filter("non-empty", |s| !s.is_empty())
}

/// Generate arbitrary strings (may or may not be valid).
fn arb_any_string() -> impl Strategy<Value = String> {
    prop_oneof![
        // Empty string
        Just(String::new()),
        // Valid names
        arb_valid_name(),
        // Names starting with special characters
        prop::string::string_regex("[._-][a-zA-Z0-9]{0,10}").unwrap(),
        // Names with unicode
        prop::string::string_regex("[a-z]{1,3}[\u{0080}-\u{00FF}]{1,3}").unwrap(),
        // Names with spaces
        prop::string::string_regex("[a-z]{1,3} [a-z]{1,3}").unwrap(),
        // Names with slashes (invalid â€” conflict with S3 key paths)
        prop::string::string_regex("[a-z]{1,3}/[a-z]{1,3}").unwrap(),
        // Very long names (around the 255 limit)
        prop::string::string_regex("[a-zA-Z][a-zA-Z0-9]{250,260}").unwrap(),
        // Single characters
        prop::string::string_regex("[a-zA-Z0-9._-]").unwrap(),
    ]
}

// ---- Property Tests ----

proptest! {
    /// Production validation matches reference for arbitrary inputs.
    #[test]
    fn validation_matches_reference(name in arb_any_string()) {
        let production = is_valid_namespace_name(&name);
        let reference = reference_validate(&name);
        prop_assert_eq!(production, reference,
            "Validation mismatch for name {:?}: production={} reference={}",
            name, production, reference);
    }

    /// All names generated by the valid strategy pass validation.
    #[test]
    fn valid_names_pass(name in arb_valid_name()) {
        prop_assert!(is_valid_namespace_name(&name),
            "Valid name {:?} should pass validation", name);
    }

    /// Empty string always fails.
    #[test]
    fn empty_always_fails(_dummy in 0..1u32) {
        prop_assert!(!is_valid_namespace_name(""));
    }

    /// Names starting with non-alphanumeric always fail.
    #[test]
    fn non_alnum_start_fails(
        prefix in prop::sample::select(vec!['.', '_', '-', ' ', '/', '\\', '@', '#']),
        suffix in "[a-zA-Z0-9]{0,10}",
    ) {
        let name = format!("{}{}", prefix, suffix);
        prop_assert!(!is_valid_namespace_name(&name),
            "Name starting with {:?} should fail: {:?}", prefix, name);
    }

    /// Names with only valid characters and alphanumeric start pass.
    #[test]
    fn alphanumeric_start_valid_chars_pass(
        first in "[a-zA-Z0-9]",
        rest in "[a-zA-Z0-9._-]{0,50}",
    ) {
        let name = format!("{}{}", first, rest);
        prop_assert!(is_valid_namespace_name(&name),
            "Name {:?} should be valid", name);
    }

    /// Names longer than 255 characters always fail.
    #[test]
    fn too_long_fails(
        name in "[a-zA-Z][a-zA-Z0-9]{255,300}",
    ) {
        prop_assert!(!is_valid_namespace_name(&name),
            "Name with {} chars should fail (> 255)", name.len());
    }

    /// Exactly 255 characters is valid.
    #[test]
    fn max_length_valid(
        rest in "[a-zA-Z0-9]{254,254}",
    ) {
        let name = format!("a{}", rest);
        prop_assert_eq!(name.len(), 255);
        prop_assert!(is_valid_namespace_name(&name),
            "255-char name should be valid");
    }

    /// Names with spaces always fail.
    #[test]
    fn spaces_fail(
        before in "[a-zA-Z]{1,5}",
        after in "[a-zA-Z]{1,5}",
    ) {
        let name = format!("{} {}", before, after);
        prop_assert!(!is_valid_namespace_name(&name),
            "Name with space should fail: {:?}", name);
    }

    /// Names with forward slashes always fail (important: S3 key conflict).
    #[test]
    fn slashes_fail(
        before in "[a-zA-Z]{1,5}",
        after in "[a-zA-Z]{1,5}",
    ) {
        let name = format!("{}/{}", before, after);
        prop_assert!(!is_valid_namespace_name(&name),
            "Name with slash should fail: {:?}", name);
    }

    /// Idempotency: validating the same name twice gives the same result.
    #[test]
    fn validation_idempotent(name in arb_any_string()) {
        let result1 = is_valid_namespace_name(&name);
        let result2 = is_valid_namespace_name(&name);
        prop_assert_eq!(result1, result2,
            "Validation should be deterministic for {:?}", name);
    }
}
